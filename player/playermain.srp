# playerdemo.srp - example of a bare-bones player
#
# Roger B. Dannenberg
# March 2017

# IMPORTANT: SERVICE must be defined before you load playerbase.srp:
SERVICE = "demo"

# Now load playerbase.srp
require "playerbase"

require "debug"
require "wxserpent"
require "sched"
require "midi-io"
require "prefs"
require "mididevice"
require "slider"

require "prob"
require "mfread"
require "../transition_matrix"

val1 = -1
val2 = -1
weight1 = 0
weight2 = 1 - weight1

///////////////////////////////////
//Touch osc code
///////////////////////////////////

APPLICATION = "p5"
SERVICE = "p5"
PORT = 8213

# make a full path with SERVICE prefix
def full(osc_path)
    # make a full O2 path based on SERVICE
    return "/" + SERVICE + osc_path

o2_initialize(APPLICATION, false)
o2_service_new(SERVICE)
o2_clock_set()


def install_handlers()
    o2_method_new(full("/2/multitoggle1/4/1"), "f", 'button1', true)
    o2_method_new(full("/2/multitoggle1/3/1"), "f", 'button2', true)
    o2_method_new(full("/2/multitoggle1/2/1"), "f", 'button3', true)
    o2_method_new(full("/2/multitoggle2/4/1"), "f", 'button4', true)
    o2_method_new(full("/2/multitoggle2/3/1"), "f", 'button5', true)
    o2_method_new(full("/2/multitoggle2/2/1"), "f", 'button6', true)
    o2_method_new(full("/faderM"), "f", 'slider', true)


# o2_initialize("o2osc", t)
# o2_osc_delegate("oscsend", "192.168.1.122", 8213, false)
# o2_send_start()
# o2_send_finish(0.0, "/oscsend/label hello", false)

def button1(timestamp, address, types, val) 
    val1 = 0
def button2(timestamp, address, types, val) 
    val1 = 1
def button3(timestamp, address, types, val) 
    val1 = 2
def button4(timestamp, address, types, val) 
    val2 = 0
def button5(timestamp, address, types, val) 
    val2 = 1
def button6(timestamp, address, types, val) 
    val2 = 2
def slider(timestamp, address, types, val)
    weight1 = val



if len(command_line_arguments) > 1 and
   command_line_arguments[1] == "d" // set up for donttouchosc
    install_donttouchosc_handlers()
else
    if len(command_line_arguments) > 1 and
       isdigit(command_line_arguments[1])
        osc_port = int(command_line_arguments[1])
    # install_generic_handler()
    install_handlers()


rslt = o2_osc_port_new(SERVICE, PORT, false)
if rslt != 0 // an error occurred
    display "in int.srp, o2_osc_port_new returned ERROR", rslt



///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
// Markov Stuff
///////////////////////////////////////////////////////////////////

# Associated names of transition matrices
TM_NAMES = ["Game", "Classical", "Rock"]

# Populated with actual transition matrices
TM_LIST = []

# Loading of precomputed transition matrices
for type_name in TM_NAMES:
    var tm_file_path = wxs_file_selector("Open a Transition Matrix for " + type_name,
                             "", "", ".csv", "*.csv", WXS_FILE_OPEN, 0)
    var tmp_tm = TransitionMatrix()
    tmp_tm.read(tm_file_path)
    TM_LIST.append(tmp_tm)

print "Loaded transition matrices!"

def get_current_tm():
    if (val1 == -1 and val2 == -1)
        return nil
    # TODO: Use states updated from TouchOSC
    # There are one or two styles selected by user in TouchOSC
    # If one, just return the matrix for that style
    if (val1 != -1 and val2 == -1)
        return TM_LIST[val1]
    elif (val1 == -1 and val2 != -1)
        return TM_LIST[val2]
    # If two, use tm1.combine(tm2, CURR_WEIGHT) where CURR_WEIGHT comes from TouchOSC too
    else
        return tm1.combine(tm2, weight1)
    # Return the value of that
    # return TM_LIST[0]

def get_next_state(tm, state):
    var curr_idx = tm.state_to_idx(state)
    var mat = tm.mat
    var next_idx = pr_markov_next(curr_idx, mat)
    var next_state = tm.idx_to_state(next_idx)
    return next_state

def pick_starting_dur(tm, pitch):
    durs = []

    for dur in tm.durs:
        var idx = tm.state_to_idx([pitch, dur])
        if sum_row(tm.mat[idx]) >= 1.0:
            durs.append(dur)

    return pr_choice(durs)

def pick_starting_pitch(cur_chord):
    pitches = []
    for pitch = 0 to 12:
        if cur_chord[pitch]:
            pitches.append(pitch)
    return pr_choice(pitches)

def play_a_measure()
    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    display "play_a_measure", cur_beats_per_measure, cur_bps
    display "    ", cur_scale, cur_chord, cur_bass
    # Use EPSILON here because comparing floats for equality is not
    #   reliable without very difficult analysis. So, instead of
    #   x >= y, we write x + EPSILON > y
    if cur_style == 'rock'

        # Play an arpegio with the current chord
        var total_beats = 0
        var i = 0
        var prev_pitch = nil
        var prev_dur = nil
        sched_select(vtsched)
        for pitch = 0 to 12:
            if cur_chord[pitch]:
                sched_cause(i * 0.25, midi_out, 'note',
                            0, 60 + pitch, vel(100), 0.3)
                i = i + 1
                prev_pitch = pitch

        # Continue the rest of the measure with the Markov chain, only
        # playing notes within the scale
        prev_dur = 0.25
        total_beats = total_beats + i * 0.25

        tm = get_current_tm()
        while total_beats < 4:
            var next_state = get_next_state(tm, [prev_pitch, prev_dur])
            var next_pitch = next_state[0]
            var next_dur = next_state[1]

            sched_select(vtsched)
            if cur_scale[next_pitch]:
                sched_cause(total_beats, midi_out, 'note',
                            0, next_pitch + 60, vel(100), next_dur)
                total_beats = total_beats + next_dur
            prev_pitch = next_pitch
            prev_dur = next_dur
